; [Comments translated from German to English]

; *****************************************************************************
; *                                                                           *
; *           Card-specific routines for the SVGA.BGI driver                  *
; *                                                                           *
; * (C) 1990-94 by                                                            *
; * Ullrich von Bassewitz                                                     *
; * Zwehrenbhlstraáe 33                                                      *
; * D-72070 Tbingen                                                          *
; *                                                                           *
; * E-Mail: uz@ibb.schwaben.de                                                *
; *                                                                           *
; *****************************************************************************



;---------------------------------------------------------------------
;
; The following routines are card-specific for cards from different manufacturers
; or with different chipsets.
;
; Set 64-K segment in [Seg64]. All registers preserved
; Attention: The data segment may not be correct, so always load ds separately
;

PROC    ET3000_SegSwitch NEAR

        push    dx
        push    ax
        mov     dx, ds
        SetToDS ds
        mov     al, [Seg64]
        mov     ds, dx
        mov     ah, al
IF P80286
        shl     al, 3
ELSE
        shl     al, 1
        shl     al, 1
        shl     al, 1
ENDIF
        or      al, ah
        or      al, 40h                 ; Segment configuration
        mov     dx, 3CDh
        out     dx, al
        pop     ax
        pop     dx
        ret

ENDP    ET3000_SegSwitch


; ----------------------------------------------
; ET 4000

PROC    ET4000_SegSwitch NEAR

        push    dx
        push    ax
        mov     dx, ds
        SetToDS ds
        mov     al, [Seg64]
        mov     ds, dx
        mov     ah, al
IF P80286
        shl     al, 4
ELSE
        shl     al, 1
        shl     al, 1
        shl     al, 1
        shl     al, 1
ENDIF
        or      al, ah
        mov     dx, 3CDh
        out     dx, al
        pop     ax
        pop     dx
        ret

ENDP    ET4000_SegSwitch

; ----------------------------------------------
; Video7


PROC    V7_SegSwitch    NEAR

        push    ax
        push    cx
        push    dx
        mov     dx, ds
        SetToDS ds
        mov     ch, [Seg64]             ; Get segment
        mov     ds, dx
        cli

; Unlock extended registers

        mov     dx, 3C4h
        mov     ax, 0EA06h
        out     dx, ax

; Bank 0 bit

        mov     al, 0F9h
        mov     ah, ch
        and     ah, 1
        out     dx, ax

; Bank 1 bit

        mov     dl, 0CCh                ; dx = 3CCh
        in      al, dx
        and     al, 0DFh                ; Set bit 5 to 0
        mov     ah, al                  ; ah is temp
        mov     al, ch                  ; Segment in al
        and     al, 2                   ; Page and 2
IF P80286
        shl     al, 4
ELSE
        mov     cl, 4
        shl     al, cl                  ; (Page and 2) shl 4;
ENDIF
        or      al, ah                  ; temp or ((Page and 2) shl 4);
        mov     dl, 0C2h                ; dx = 3C2h
        out     dx, al

; Bank 2 bit
	Add2	dx			; dx = 3c4h
        mov     al, 0F6h
        out     dx, al

        inc     dx                      ; dx = 3c5h
        in      al, dx                  ; al is temp
        and     al, 0FAh                ; Clear bits 0 and 2
        and     ch, 4                   ; Page, bit 2
        or      al, ch                  ; temp or (Page and 4)
IF P80286
        shr     ch, 2
ELSE
        shr     ch, 1
        shr     ch, 1                   ; ((Page and 4) shr 2);
ENDIF
        or      al, ch                  ; temp or (Page and 4) or ...
        out     dx, al

; That's it (jessas !)

        sti
        pop     dx
        pop     cx
        pop     ax
        ret

ENDP    V7_SegSwitch


; ----------------------------------------------
; Trident 8900


PROC    Trident_SegSwitch       NEAR

        push    ax
        push    dx

        cli

        mov     dx, 3CEh
        mov     ax, 0606h
        out     dx, al
        inc     dx
        in      al, dx
        dec     dx
        or      al, 04h
        xchg    ah, al                  ; ah = value, al = 6
        out     dx, ax

        mov     dl, 0C4h                ; dx = 3C4h
        mov     al, 0Bh
        out     dx, al                  ; Enable new mode control
        inc     dx
        in      al, dx
        dec     dx

        mov     dx, ds
        SetToDS ds
        mov     ah, [Seg64]             ; Get segment
        mov     ds, dx
        mov     dx, 3C4h

        xor     ah, 02h
        mov     al, 0Eh
        out     dx, ax                  ; new mode port ctrl 1

        sti
        pop     dx
        pop     ax
        ret

ENDP    Trident_SegSwitch


; ----------------------------------------------
; ATI VGA-Wonder

PROC    ATI_SegSwitch NEAR

        push    ax
        push    dx
        push    ds
        SetToDS ds
        mov     dx, [Extended_Reg]
        cli
        mov     al, 0B2h                ; Page select
        out     dx, al
        inc     dx
        in      al, dx                  ; Get old value
        and     al, 0E1h                ; Clear page bits
        mov     ah, al                  ; Save value
        mov     al, [Seg64]             ; Get segment
        shl     al, 1
        or      ah, al
        mov     al, 0B2h                ; Page select
        dec     dx
        out     dx, ax
        sti
        pop     ds
        pop     dx
        pop     ax
        ret

ENDP    ATI_SegSwitch

; ------------------------------------------------
; Paradise VGA

PROC    Par_SegSwitch NEAR

        push    ax
        push    dx
        mov     dx, 3CEh
        mov     ax, 050Fh
        cli                             ; Interrupts off
        out     dx, ax
        mov     dx, ds
        SetToDS ds
        mov     ah, [Seg64]             ; Get segment
        mov     ds, dx
IF P80286
        shl     ah, 4
ELSE
        shl     ah, 1
        shl     ah, 1
        shl     ah, 1
        shl     ah, 1
ENDIF
        mov     al, 9
        out     dx, ax
        sti                             ; Allow interrupts
        pop     dx
        pop     ax
        ret

ENDP    Par_SegSwitch


; ----------------------------------------------------
; Everex VGA

PROC    Evx_SegSwitch NEAR

        push    ax
        push    cx
        push    dx
        mov     dx, ds
        SetToDS ds
        mov     cl, [Seg64]             ; Get segment
        mov     ds, dx
        cli
        mov     dx, 03C4h
        mov     al, 08h
        out     dx, al
        inc     dx
        in      al, dx
        dec     dx
        shl     al, 1
        shr     cl, 1
        rcr     al, 1
        mov     ah, al
        mov     al, 08h
        out     dx, ax
        mov     dl, 0CCh                ; dx = 3CCh
        in      al, dx
        mov     dl, 0C2h                ; dx = 3C2h
        and     al, 0DFh
        shr     cl, 1
        jc      @@L1
        or      al, 20h
@@L1:   out     dx, al
        sti
        pop     dx
        pop     cx
        pop     ax
        ret

ENDP    Evx_SegSwitch


; ----------------------------------------------------
; OAK VGA

PROC    Oak_SegSwitch NEAR

        push    ax
        push    dx
        mov     dx, ds
        SetToDS ds
        mov     al, [Seg64]             ; Get segment
        mov     ds, dx
        mov     ah, al
IF P80286
        shl     ah, 4
ELSE
        shl     ah, 1
        shl     ah, 1
        shl     ah, 1
        shl     ah, 1
ENDIF

; From here the implementations differ. In another variant,
; only the new segment with 4 bits upper / 4 bits lower is output to 3DF.

        or      al, ah
        mov     dx, 03dFh
        out     dx, al

;       or      ah, al                  ; or    al, ah
;       mov     al, 11h
;       mov     dx, 03DEh               ; mov   dx, 03DFh
;       out     dx, ax                  ; out   dx, al
        pop     dx
        pop     ax
        ret

ENDP    Oak_SegSwitch

; ----------------------------------------------------
; VESA VGA
;
; There are two routines here: The first uses only one window (which must be readable
; and writable).
; The second is for when only a readable and a writable window are available.
;


PROC    VESA_SegSwitch1 NEAR

        push    ax
        push    bx
        push    dx
        push    ds
        SetToDS ds

        mov     al, [Seg64]             ; Get segment
        mul     [VESA_Granularity]      ; Calculate position
        xchg    ax, dx                  ; Position to dx
        mov     bx, [VESA_Window]       ; Window number
        call    [VESA_WinFunc]          ; Show window

        pop     ds
        pop     dx
        pop     bx
        pop     ax
        ret

ENDP    VESA_SegSwitch1



PROC    VESA_SegSwitch2 NEAR

        push    ax
        push    bx
        push    dx
        push    ds
        SetToDS ds

        mov     al, [Seg64]             ; Get segment
        mul     [VESA_Granularity]      ; Calculate position
        xchg    ax, dx                  ; Position to dx
        push    dx                      ; and save position
        xor     bx, bx                  ; Window number = 0
        call    [VESA_WinFunc]          ; Show window
        inc     bx                      ; Window number = 1
        pop     dx                      ; Restore old position
        call    [VESA_WinFunc]          ; Show window

        pop     ds
        pop     dx
        pop     bx
        pop     ax
        ret

ENDP    VESA_SegSwitch2



PROC    VESA_SegSwitch3 NEAR

        push    ax
        push    bx
        push    dx
        push    ds
        SetToDS ds

        mov     al, [Seg64]             ; Get segment
        mul     [VESA_Granularity]      ; Calculate position
        xchg    ax, dx                  ; Position to dx
        mov     bx, [VESA_Window]       ; Window number
        mov     ax, 4F05h               ; Function code to ax
        int     10h                     ; Show window

        pop     ds
        pop     dx
        pop     bx
        pop     ax
        ret

ENDP    VESA_SegSwitch3



PROC    VESA_SegSwitch4 NEAR

        push    ax
        push    bx
        push    dx
        push    ds
        SetToDS ds

        mov     al, [Seg64]             ; Get segment
        mul     [VESA_Granularity]      ; Calculate position
        xchg    ax, dx                  ; Position to dx
        push    dx                      ; and save
        xor     bx, bx                  ; Window number = 0
        mov     ax, 4F05h               ; Function code to ax
        int     10h                     ; Show window

        inc     bx                      ; Window number = 1
        pop     dx                      ; Position
        mov     ax, 4F05h               ; Function code to ax
        int     10h                     ; Show window

        pop     ds
        pop     dx
        pop     bx
        pop     ax
        ret

ENDP    VESA_SegSwitch4



; -------------------------------------------------------------------
; S3 VGA


PROC    S3_SegSwitch    NEAR

        push    ax
        push    bx
        push    dx
        mov     dx, ds
        SetToDS ds
        mov     bl, [Seg64]             ; Get segment
        mov     ds, dx


        mov     bh, bl                  ; Copy to bh
        and     bx, 100Fh               ; 1 bit in bh, 4 bits in bl
IF      P80286
        shr     bh, 2                   ; Bit 4 --> Bit 2
ELSE
        shr     bh, 1
        shr     bh, 1                   ; Bit 4 --> Bit 2
ENDIF

; Set the top bit (in EX_SCTL_2, CR51)

        cli
        mov     dx, 03D4h
        mov     al, 51h
        out     dx, al
        inc     dx
        in      al, dx
        and     al, 0F3h                ; Mask out 2 address bits...
        or      al, bh                  ; or them in...
        out     dx, al                  ; ... and write back

; The lower 4 bits of the address are set in CRTR_LOCK (CR35)

@@L1:   mov     dx, 03D4h
        mov     al, 35h
        out     dx, al
        inc     dx
        in      al, dx
        and     al, 0F0h
        or      al, bl
        out     dx, al

; That should be it...

        sti

        pop     dx
        pop     bx
        pop     ax
        ret

ENDP    S3_SegSwitch

; -------------------------------------------------------------------
;
; Routines for setting the write page (SetDrawPage).
; Called with:
;       ax      = page to set
;       ds      = data segment
;

PROC    Generic_DrawPage

; Calculate the Y-offset from the page in ax, by which all Y-coordinates are shifted.
; Store this offset.

        mul     [MaxY]
        mov     [PageOfs], ax

; done

        ret

ENDP    Generic_DrawPage


PROC    S3_DrawPage

; S3 cards have the peculiarity that after the first page 8 lines are reserved, where
; a copy of the fill pattern is stored for use with the hardware engine.

        test    ax, ax                  ; Page = 0?
        jz      @@L1                    ; Ok, offset is 0
        mul     [MaxY]                  ; otherwise times screen height
        add     ax, 8                   ; + 8 lines
@@L1:   mov     [PageOfs], ax

; done

        ret

ENDP    S3_DrawPage


; --------------------------------------------------------------
;
; Card-specific routines for setting the display page
;
; Called with:
;       ax      = page to set
;       ds      = data segment


; Subroutine to set the lower 16 bits of the start address (these
; are identical on all cards). ATTENTION: The function returns with interrupts disabled
; and the value 03D4h in dx. dx and ax are destroyed.

PROC    SetStartAdrLow  NEAR

        push    ax
        mov     dx, 03D4h
        mov     ah, al
        mov     al, 0DH
        cli
        out     dx, ax                  ; CRTC register 0Dh, low byte
        pop     ax
        mov     al, 0Ch
        out     dx, ax                  ; CRTC register 0Ch, high byte

        ret

ENDP    SetStartAdrLow


; Subroutine to calculate the byte offset of a given screen
; page in ax. Result is returned in bx:ax, dx is destroyed.

PROC    CalcPageOffset  NEAR

        mov     bx, ax
        mul     [WORD HIGH ScreenBytes]
        xchg    bx, ax
        mul     [WORD LOW ScreenBytes]
        add     bx, dx
        shr     bx, 1
        rcr     ax, 1
        shr     bx, 1
        rcr     ax, 1                   ; / 4
        ret

ENDP    CalcPageOffset



PROC    ET3000_VisualPage

; Calculate the byte offset.

        call    CalcPageOffset          ; Byte offset in bx:ax
        shl     bx, 1                   ; Must be in bit 1 for later
        and     bl, 02h                 ; Bit 19

; Set lower 16 bits

        call    SetStartAdrLow

; Output bit 19

        mov     al, 23h
        out     dx, al
        inc     dx
        in      al, dx
        and     al, 0FDh                ; It's bit 2 ...
        or      al, bl
        out     dx, al
        sti
        ret

ENDP    ET3000_VisualPage




PROC    ET4000_VisualPage

; Calculate the byte offset.

        call    CalcPageOffset          ; Byte offset in bx:ax
        and     bl, 03h                 ; Bits 19/20

; Set lower 16 bits

        call    SetStartAdrLow

; Set upper 2 bits

        mov     al, 33h                 ; Register 33h (TSENG ET4000)
        out     dx, al
        inc     dx
        in      al, dx                  ; Read value
        and     al, 0FCh                ; Mask lower two bits
        or      al, bl
        out     dx, al
        sti
        ret

ENDP    ET4000_VisualPage




PROC    Trident_VisualPage

; Calculate the byte offset.

        call    CalcPageOffset          ; Byte offset in bx:ax
IF      P80286
        shl     bx, 2
ELSE
        shl     bx, 1
        shl     bx, 1
ENDIF
        mov     bh, bl                  ; Copy of high byte to bh

        mov     cl, 3                   ; 286 opt. not worth it
        shl     bl, cl
        shr     bh, cl

        and     bx, 0120h               ; Mask bit 19 (bl) and 20 (bh)

; Set lower 16 bits

        call    SetStartAdrLow

; Set upper 2 bits

        mov     al, 1Eh                 ; Index
        out     dx, al
        inc     dx
        in      al, dx
        and     al, 5Fh
        or      al, 80h
        or      al, bl
        out     dx, al

        mov     dl, 0CEh                ; dx = 3CEh
        mov     ax, 0B011h
        out     dx, ax
        mov     al, 0Eh
        out     dx, al
        inc     dx
        in      al, dx
        and     al, 0FEh
        or      al, bh
        out     dx, al
        sti
        ret

ENDP    Trident_VisualPage




PROC    V7_VisualPage

; Calculate the byte offset.

        call    CalcPageOffset          ; Byte offset in bx:ax
        and     bl, 03h                 ; Mask bit 19/20

IF      P80286
        shl     bl, 4
ELSE
        shl     bl, 1
        shl     bl, 1
        shl     bl, 1
        shl     bl, 1
ENDIF

; Set lower 16 bits

        call    SetStartAdrLow

; Set bits 19/20

        mov     al, 0F6h
        mov     dl, 0CEh                ; dx = 3CEh
        out     dx, al
        inc     dx
        in      al, dx
        and     al, 08Fh
        or      al, bl
        out     dx, al
        sti
        ret

ENDP    V7_VisualPage




PROC    Par_VisualPage

; Calculate the byte offset.

        call    CalcPageOffset          ; Byte offset in bx:ax
IF      P80286
        shl     bl, 3
ELSE
        shl     bl, 1
        shl     bl, 1
        shl     bl, 1
ENDIF
        and     bl, 018h                ; Bits 19/20

; Set lower 16 bits

        call    SetStartAdrLow

; Set bits 19/20

        mov     al, 0Dh                 ; Index
        mov     dl, 0CEh                ; dx = 3CEh
        out     dx, al
        inc     dx
        in      al, dx
        and     al, 0E7h
        or      al, bl
        out     dx, al
        sti
        ret

ENDP    Par_VisualPage



PROC    S3_VisualPage

; Calculate the byte offset. For the S3 card, 8 lines are left free above 
; the first page, where a copy of the fill pattern is stored.
; Due to the fact that 4 planes are used, the page offset is 4 times smaller, 
; so (virtually) 2 lines must be added.

        xor     bx, bx
        test    ax, ax                  ; Page = 0 ?
        jz      @@L1                    ; Yes: offset 0
        call    CalcPageOffset          ; Page offset to bx:ax
        add     ax, [BytesPerLine]
        adc     bx, 0
        add     ax, [BytesPerLine]
        adc     bx, 0
@@L1:   mov     bh, bl                  ; Copy of low byte to bh

IF      P80286
        shl     bl, 4
        shr     bh, 2
ELSE
        shl     bl, 1
        shl     bl, 1
        shl     bl, 1
        shl     bl, 1
        shr     bh, 1
        shr     bh, 1
ENDIF
        and     bx, 0130h               ; Mask bit 18 in bh, 16/17 in bl

; Set lower 16 bits

        call    SetStartAdrLow

; Set bits 16/17

        mov     al, 31h                 ; Register 31h (MEM_CNFG)
        out     dx, al
        inc     dx
        in      al, dx                  ; Read value
        and     al, 0CFh                ; Mask lower two bits
        or      al, bl
        out     dx, al

; Set bit 18

        dec     dx
        mov     al, 51h
        out     dx, al
        inc     dx
        in      al, dx
        and     al, 0FEh
        or      al, bh
        out     dx, al

        sti
        ret

ENDP    S3_VisualPage


PROC    VESA_VisualPage

        mul     [MaxY]                  ; Calculate line
        mov     dx, ax                  ; Line to dx
        mov     ax, 4F07h               ; VESA/Display Start Control
        xor     bx, bx                  ; Select display start
        xor     cx, cx                  ; First display pixel in line
        int     10h                     ; Switch...
        ret

ENDP    VESA_VisualPage


; ---------------------------------------------------------------
;
; VESA: Get data of the mode to be enabled
; Entry: di = pointer to mode descriptor
; As a small optimization, an attempt is made to find a window that is 
; readable and writable in order to use the short switching routine. Only if
; this is not possible, the long switching routine (with two windows) is used.
; The whole thing is somewhat complicated by the fact that in protected mode
; the optimization is possible that the VESA segment switching can be called 
; in PM if the corresponding flag is set. So one of a total of 4 segment 
; switching routines must be assigned accordingly.


PROC    VESA_GraphOn NEAR

        mov     ax, 4F01h                       ; Data request
        mov     cx, [(TMode di).BIOSbx]         ; VESA mode number

IF      Ver3

; Get info about the memory windows. Unfortunately, this must be done 
; differently for RM and PM...
; Since the segment switching routines used (for speed) are also different, 
; the following evaluation is mostly separate.

        cmp     [ProtMode], 0
        jz      @@L1                            ; Jump if REAL mode

; Get info in protected mode. The information is packed into a 
; "RealModeRegs" structure and the REAL mode interrupt is simulated.
; This is necessary because segment registers are passed.
; Afterwards, even if the corresponding options flag is set, a descriptor 
; for the code segment of the real mode switching routine is always built
; and entered instead of the segment.
; The further processing is the same as in REAL mode.

        mov     [RMRegs.rAX], ax                ; ax = 4F00h
        mov     [RMRegs.rCX], cx
        mov     ax, [LowBufSeg]
        mov     [RMRegs.rES], ax
        xor     ax, ax
        mov     [RMRegs.rDI], ax
        mov     [RMRegs.rSP], ax
        mov     [RMRegs.rSS], ax                ; Use DPMI stack
        mov     bx, 0010h                       ; Interrupt number
        xchg    ax, cx                          ; cx = 0
        mov     ax, 0300h
        push    ds
        pop     es
        lea     di, [RMRegs]                    ; Pointer to struct in es:di
        int     31h                             ; Simulate real mode interrupt
        mov     es, [LowBufSel]
        xor     di, di

; Enter protected mode code segment

        mov     ax, [WORD HIGH (VESA_InfoBlock es:di).WinFunc]
        call    DPMI_SegToDesc                  ; Create descriptor
        call    DPMI_MakeCodeDesc               ; points to executable code
        mov     [WORD HIGH (VESA_InfoBlock es:di).WinFunc], bx

        jmp     @@L2

; Get VESA info in real mode.

@@L1:   xor     di, di
        mov     es, [LowBufSeg]                 ; es:di --> buffer memory
        int     10h                             ; Call VESA BIOS

ELSE

; Get VESA info in real mode.

@@L1:   lea     di, [LowBuf]
        SetToDS es                              ; es:di --> buffer memory
        int     10h                             ; Call VESA BIOS

ENDIF

; VESA info was successfully obtained, es:di points to the VESA info block.
; First, get the number of bytes per scan line and store in the global 
; variable BytesPerLine. This overwrites the default from Init, so far it 
; contains the same value as in MaxX.

@@L2:   mov     ax, [(VESA_InfoBlock es:di).BytesPerLine]
        mov     [BytesPerLine], ax

; Then evaluate the window attributes

        mov     al, [(VESA_InfoBlock es:di).Win_A_Attributes]
        and     al, 07h                         ; lowest bits
        cmp     al, 07h                         ; Window A readable/writable?
        jnz     @@L3                            ; No

; Window A is readable/writable, remember

        mov     [VESA_Window], 0                ; Window number is 0
        jmp     @@L4

; Window A is not readable/writable, check window B

@@L3:   mov     al, [(VESA_InfoBlock es:di).Win_B_Attributes]
        and     al, 07h                         ; lowest bits
        cmp     al, 07h                         ; Window B readable/writable?
        jnz     @@L5                            ; No

; Window B is readable/writable, remember

        mov     [VESA_Window], 1                ; Window number is 1
@@L4:   mov     ax, OFFSET VESA_SegSwitch1      ; Fast routine
        mov     bx, OFFSET VESA_SegSwitch3      ; Slow routine
        jmp     @@L6

; Neither window is readable and writable.

@@L5:   mov     ax, OFFSET VESA_SegSwitch2
        mov     bx, OFFSET VESA_SegSwitch4
@@L6:   cmp     [ProtMode], 0                   ; Protected mode?
        jz      @@L7                            ; Jump if not
        test    [Options], OpFastVesaOff        ; Optimization off?
        jz      @@L7                            ; Jump if not
        xchg    ax, bx                          ; Otherwise slow routine
@@L7:   mov     [SegSelect], ax

; Get pointer to switching routine

        mov     ax, [WORD LOW (VESA_InfoBlock es:di).WinFunc]
        mov     [WORD LOW VESA_WinFunc], ax
        mov     ax, [WORD HIGH (VESA_InfoBlock es:di).WinFunc]
        mov     [WORD HIGH VESA_WinFunc], ax

; Calculate conversion factor for granularity

@@L9:   mov     ax, 64                          ; 64 (KB) to ax
        div     [BYTE LOW (VESA_InfoBlock es:di).Win_Granularity]
        mov     [VESA_Granularity], al          ; and remember

; Done

        ret

ENDP    VESA_GraphOn


; -------------------------------------------------------------------
; Special enable routine for ATI cards. Gets the address of the extended
; register
;

PROC    ATI_GraphOn Near

        mov     es, [SegC000]
        mov     ax, [es:10h]
        mov     [Extended_Reg], ax
        ret

ENDP    ATI_GraphOn


; -------------------------------------------------------------------
; Special enable routine for ET4000. Unlocks the extended registers
;

PROC    ET4000_GraphOn  NEAR

        mov     dx, 3BFh
        mov     al, 03h
        out     dx, al
        mov     dx, 03D8h
        mov     al, 0A0h
        out     dx, al
        ret

ENDP    ET4000_GraphOn

; -------------------------------------------------------------------
; Special enable routine for S3 cards. Unlocks the extended registers

;

PROC    S3_GraphOn      NEAR

        mov     dx, 03D4h
        mov     ax, 04838h              ; REG_LOCK1 (CR38)
        out     dx, ax                  ; unlock...

        mov     ax, 0A039h              ; REG_LOCK2 (CR39)
        out     dx, ax                  ; unlock...

        mov     al, 31h                 ; MEM_CNFG (CR31)
        cli
        out     dx, al
        inc     dx
        in      al, dx
        or      al, 09h                 ; CPUA = 1, ENH MAP = 1
        out     dx, al

        dec     dx
        mov     al, 40h                 ; SYS_CNFG (CR40)
        out     dx, al
        inc     dx
        in      al, dx
        or      al, 01h                 ; Enable enhanced register access
        out     dx, al
        sti

        test    [Options], OpNoS3Hardware
        jnz     @@L1
        mov     [Vector_Table + FuncClear], OFFSET S3_Clear
        mov     [Vector_Table + FuncVect], OFFSET S3_Vect
        mov     [Vector_Table + FuncFillStyle], OFFSET S3_FillStyle
        mov     [Vector_Table + FuncPatBar], OFFSET S3_PatBar

        mov     [HorLine], OFFSET S3_HorLine
        mov     [HorLineInit], OFFSET S3_HorLineInit
        mov     [GE_Ready], OFFSET S3_Ready


@@L1:   ret

ENDP    S3_GraphOn