; [Comments translated from German to English]

; *****************************************************************************
; *                                                                           *
; *          Automatic card detection for the SVGA.BGI driver                 *
; *                                                                           *
; * (C) 1990-94 by                                                            *
; * Ullrich von Bassewitz                                                     *
; * Zwehrenbhlstraáe 33                                                      *
; * D-72070 Tbingen                                                          *
; *                                                                           *
; * E-Mail: uz@ibb.schwaben.de                                                *
; *                                                                           *
; *****************************************************************************



; -----------------------------------------------------------------
;
; Subroutines for autodetect
;

; VESACapabilities expects in es:di a pointer to the VESA buffer and returns
; in bh a bitset indicating the supported modes.
;

PROC    VESACapabilities NEAR

        push    ds

; Make the segment of Vide_Mode_Ptr into a selector

        mov     ax, [WORD es:di+16]             ; Video_Mode_Ptr, segment
        call    DPMI_SegToDesc
        mov     ds, bx                          ; Segment to ds

        mov     si, [WORD es:di+14]             ; Offset to si
        mov     ch, M320x200                    ; This mode always works
        cld

; Fetch and check modes one after another

@@L3:   lodsw
        cmp     ax, 0100h                       ; Mode 640x400 ?
        jnz     @@L4
        or      ch, M640x400

@@L4:   cmp     ax, 0101h                       ; Mode 640x480 ?
        jnz     @@L5
        or      ch, M640x480

@@L5:   cmp     ax, 0103h                       ; Mode 800x600 ?
        jnz     @@L6
        or      ch, M800x600

@@L6:   cmp     ax, 0105h                       ; Mode 1024x768 ?
        jnz     @@L7
        or      ch, M1024x768

@@L7:   cmp     ax, 0107h                       ; Mode 1280x1024 ?
        jnz     @@L8
        or      ch, M1280x1024

@@L8:   cmp     ax, 0FFFFh                      ; End of list ?
        jnz     @@L3                            ; No, next

; Done, everything checked. Release the descriptor again

        mov     bx, ds                          ; Selector to bx
        pop     ds                              ; Restore data segment
        call    DPMI_FreeDesc                   ; Release descriptor

; And done

        mov     bx, cx                          ; Mode-Bitset to bh
        ret

ENDP    VESACapabilities


; Subroutine to check for ETX000

PROC    ETSub   NEAR

        mov     al, 33h
        mov     ch, ah          ; Save test value
        out     dx, ax          ; Write value
        mov     al, 33h         ; ???
        out     dx, al
        inc     dx
        in      al, dx
        and     al, 0Fh
        dec     dx
        cmp     al, ch
        ret

ENDP    ETSub


; Test programs for the Paradise VGA. Checks if the segments can be switched
; in text mode (or something like that .... ?!?!)
;
; CheckParadise returns with the zero flag set on Paradise and with z=0
; if there is no Paradise.
;
; Called with
;   es = 0b800h
;   dx = Segment switch port
;   al = Sequencer register number for segment switching (9)
;   bx = Test value (bh/bl)
;

PROC    CheckParadise NEAR

        mov     si, bx                  ; Remember test value
        mov     ah, 1                   ; Page 1
        out     dx, ax                  ; set
        xchg    bl, [BYTE es:di]        ; Set test value 1
        xor     ah, ah                  ; Page 0
        out     dx, ax                  ; set
        xchg    bh, [BYTE es:di]        ; Set test value 2
        mov     cx, bx                  ; Remember value
        mov     bx, si                  ; Original test value to bx
        mov     ah, 1                   ; Page 1
        out     dx, ax                  ; set
        xor     bl, [BYTE es:di]        ; Check value
        mov     [BYTE es:di], cl        ; Set original value
        xor     ah, ah                  ; Page 0
        out     dx, ax                  ; set
        xor     bh, [BYTE es:di]        ; Check test value 2
        mov     [BYTE es:di], ch        ; Set original value
        test    bx, bx                  ; bx should be 0 now due to XOR
        ret

ENDP    CheckParadise


; Test program to determine the amount of memory on the card.
; Called with bl=Card number and bh=Bitset with supported modes.
; Switches to mode 0 and writes a pattern to the 64KB banks.
; Destroys all registers except ds, bx.

PROC    Adjust NEAR
Local   Card:WORD, VideoMode: BYTE = LocalSize

        EnterProc LocalSize

        mov     [Card], bx              ; Save values

        mov     ax, 0F00h               ; Get Video Mode
        call    Int10
        mov     [VideoMode], al         ; Save Video Mode

        mov     ax, 13h
        call    Int10

	IF P80386        
		movzx   bx, [BYTE LOW Card]
	ELSE
		mov     bl, [BYTE LOW Card]
        	xor     bh, bh
	ENDIF
        shl     bx, 1
        mov     bx, [SegSwitchTable+bx] ; Address of switch routine

        mov     ax, 0Fh                 ; highest segment
        mov     cx, 16                  ; 16 * 64KB for 1MB
        mov     es, [VideoSeg]
        xor     di, di
@@L1:   mov     [Seg64], al
        call    bx                      ; Select segment
        mov     [es:di], al
        dec     ax                      ; = dec al
        loop    @@L1

        mov     cx, 16
@@L2:   inc     ax
        mov     [Seg64], al
        call    bx
        cmp     [es:di], al
        jnz     @@L3
        loop    @@L2

; Result = Number of 64KB banks - 1 in al

@@L3:   mov     bx, [Card]              ; Original value
        cmp     al, 15
        je      @@L4
        and     bh, NOT M1024x768       ; Disable mode
        cmp     al, 7
        jae     @@L4
        and     bh, NOT (M800x600 OR M640x480)
@@L4:

; Restore old video mode

	IF P80386        
		movzx     ax, [VideoMode]
	ELSE
	        mov     al, [VideoMode]          ; Original video mode
        	xor     ah, ah                   ; = Set mode
	ENDIF

        push    bx                      ; Save card/modes
        call    Int10
        pop     bx

; Done

        LeaveProc
        ret

ENDP    Adjust



; -----------------------------------------------------------------------------
;
; Autodetect
; The attempt to find out the video card.
; Returned in bl is the card number (see constant part), in bh a
; BitSet that provides information about the supported resolutions.
;
; Destroys quite a few registers, except for CS, DS, SS, SP, BP
;
; The following order is used for checking:
;
;  * VGA
;  * VESA
;  * ATI
;  * Video7
;  * Everex
;  * Trident
;  * ET3000/ET4000
;  * Paradise
;  * Oak
;

PROC    AutoDetect      NEAR

        push    bp

; General check for VGA

        mov     ax, 1A00h
        call    Int10
        xor     bx, bx                  ; Card and capabilities in bl, bh
        cmp     al, 1Ah                 ; VGA ?
        jnz     AutoDetectEnd           ; No, not VGA

; It is a VGA. First, switch to text mode

        mov     ax, 3
        call    Int10

; Check for VESA cards

        test    [Options], OpNoVesa     ; Perform VESA test ?
        jnz     NoVesa                  ; Jump if no
IF      Ver3
        cmp     [ProtMode], 0           ; Are we in protected mode ?
        jz      @@L1                    ; Jump if no

; Get VESA info in protected mode. This requires packing the information into a
; "RealModeRegs" structure and simulating the REAL-mode interrupt.
; This is necessary because segment registers are passed.
; Further processing is the same as in REAL mode.

        mov     [RMRegs.rAX], 4F00h     ; ax = 4F00h
        mov     ax, [LowBufSeg]
        mov     [RMRegs.rES], ax
        xor     ax, ax
        mov     [RMRegs.rDI], ax
        mov     [RMRegs.rSP], ax
        mov     [RMRegs.rSS], ax        ; Use DPMI stack
        mov     bx, 0010h               ; Interrupt number
        xchg    ax, cx                  ; cx = 0
        mov     ax, 0300h
        push    ds
        pop     es
        lea     di, [RMRegs]            ; Pointer to struct in es:di
        int     31h                     ; Simulate real mode interrupt
        mov     ax, [RMRegs.rAX]
        mov     es, [LowBufSel]
        xor     di, di
        jmp     @@L2

; Get VESA info in real mode.

@@L1:   xor     di, di
        mov     es, [LowBufSeg]         ; es:di --> Reserved memory
        mov     ax, 4F00h               ; VESA code
        call    Int10
ELSE

; Get VESA info in real mode.

@@L1:   lea     di, [LowBuf]
        SetToDS es                      ; es:di --> Low memory buffer
        mov     ax, 4F00h               ; VESA code
        call    Int10

ENDIF

; Check if a VESA interface is present based on the info.

@@L2:   cmp     ax, 004Fh               ; VESA ?
        jnz     NoVESA                  ; No
        cmp     [WORD es:di], 'EV'
        jnz     NoVESA
        cmp     [WORD es:di+2], 'AS'
        jnz     NoVESA
        call    VESACapabilities        ; Get possible modes
        mov     bl, VESAVGA             ; Set card
        jmp     AutoDetectEnd           ; And done

; No VESA card, check S3

NoVESA: mov     dx, 03D4h
        mov     ax, 04838h
        out     dx, ax
        inc     dx
        in      al, dx
        and     al, 48h
        cmp     al, 48h
        jnz     NoS3
        dec     dx
        mov     al, 30h
        out     dx, al
        inc     dx
        in      al, dx
        cmp     al, 81h
        jb      NoS3
        cmp     al, 0C2h
        ja      NoS3
        mov     bx, (M320x200 or M640x480) * 256 + S3VGA
        dec     dx
        mov     al, 36h                 ; CONFG_REG1
        out     dx, al
        inc     dx
        in      al, dx
        and     al, 0E0h                ; Memory size
        cmp     al, 0E0h                ; 0.5MB? Can only do 640x480
        jz      IsS3
        or      bh, M800x600 or M1024x768
        cmp     al, 0C0h                ; 1MB? Can do 800x600 + 1024x768
        jz      IsS3
        or      bh, M1280x1024          ; 2MB can also do 1280x1024
IsS3:   jmp     AutoDetectEnd

; No S3 card, check ATI next. The ATI has an identification string at 0C000h:0031h
; and a VGA identification string at 0C000h:0040h.

NoS3:   mov     es, [SegC000]
        cld
        mov     di, 31h                 ; Offset ID in BIOS
        mov     si, Offset ATI_Ident
        mov     cx, SIZE ATI_Ident      ; Length of string
        repe    cmpsb                   ; Does the string match ?
        jne     NoATI
        cmp     [WORD es:40h], 3133h    ; ATI VGA ('31') ?
        jnz     NoATI                   ; No
        mov     si, OFFSET ATI_Modes
        mov     bx, (M320x200) * 256 + ATIVGA
@@L3:   lodsb                           ; Get mode number
        test    al, al                  ; End?
        jz      AutoDetectEnd           ; Jump if yes
        push    ds
        push    bx
        push    si
        mov     ah, 12h
        mov     bx, 5506h
        mov     bp, 0FFFFh
        int     10h
        pop     si
        pop     bx
        pop     ds
        lodsb                           ; Mode bitmask
        inc     bp                      ; bp == -1?
        jz      @@L3                    ; Jump if yes
        or      bh, al                  ; Reorder mode
        jmp     @@L3                    ; and next

; It is also not an ATI VGA. Check Video7 next.

NoATI:  mov     ax, 6F00h
        xor     bx, bx
        call    Int10
        cmp     bx, 'V7'                ; Video7 ?
        jnz     NoV7                    ; No
        mov     ax, 6F07h               ; Get Memory Configuration
        call    Int10
        and     ah, 7Fh                 ; Clear bit for V/D-RAM
        mov     bh, M640x400 OR M320x200; The card can always do this
        cmp     ah, 1                   ; 1 256KB bank equipped
        jbe     V71                     ; yes
        or      bh, M640x480            ; The card with 512 KB can do this
V71:    mov     bl, Video7VGA
        jmp     AutoDetectEnd
NoV7:

; It is not a Video7 card. Check Everex next.

        mov     ax, 7000h
        xor     bx, bx
        call    Int10
        cmp     al, 70h
        jnz     NoEv                    ; No Everex
        mov     bl, EverexVGA
        mov     bh, M320x200 OR M640x350 OR M640x400    ; The card can always do this
        and     ch, 0C0h                ; Memory > 256 KB
        jz      Ev1
        or      bh, M640x480 OR M800x600        ; Modes with 512 KB
Ev1:    and     dx, 0FFF0h              ; Check card
        cmp     dx, 6780h               ; Everex 678 ?
        jz      Ev2
        cmp     dx, 2360h
        jnz     Ev3
Ev2:    mov     bl, TridentVGA          ; Everex 768 = Trident 8800 !!
Ev3:    jmp     AutoDetectEnd
NoEv:

; It is not an Everex card. Check Trident next.

        mov     dx, 03C4h
        mov     al, 0Bh
        out     dx, al
        inc     dx
        in      al, dx                  ; Get version number
        cmp     al, 15
        ja      NoTri
        cmp     al, 2
        jb      NoTri
        mov     bl, TridentVGA          ; It is a Trident
        mov     bh, M320x200+M640x400+M640x480+M800x600+M1024x768
        call    Adjust                  ; Adjust to memory allocation
        jmp     AutoDetectEnd
NoTri:

; It is not a Trident, check ETX000

                                        ; Pretend to be ET3000
        mov     bx, (M320x200+M640x350+M640x480+M800x600)*256 + ET3000VGA
        mov     dx, 3D4h                ; Original value of the register
        mov     al, 33h                 ; Get 33h and remember in cl
        out     dx, al
        inc     dx
        in      al, dx
        dec     dx
        mov     cl, al

        mov     ax, 0A33h
        call    ETSub
        jnz     IsET3                   ; Not ET4000

        mov     ax, 0533h
        call    ETSub
        jnz     IsET3                   ; Not ET4000

        mov     al, 33h
        mov     ah, cl                  ; Restore original value
        out     dx, ax                  ; restore

        mov     bx, (M320x200+M640x350+M640x400+M640x480+M800x600+M1024x768)*256 + ET4000VGA

        mov     dx, 3BFh
        mov     al, 03h
        out     dx, al
        mov     dl, 0D8h                ; dx = 3D8h
        mov     al, 0A0h
        out     dx, al
        jmp     SHORT IsET4

; After distinguishing ET3000/ET4000, check if the segment select
; register is in the correct place. If it is not readable/writable,
; then - no matter how the previous test turned out - there is no ETX000.

IsET3:  mov     al, 33h
        mov     ah, cl                  ; Restore original value
        out     dx, ax                  ; restore

IsET4:  mov     dx, 03CDh               ; Segment select of ET3000/4000
        in      al, dx
        mov     si, ax                  ; Remember original value

        mov     cx, 0FFh                ; Start with $FF
ETLp:   mov     al, cl                  ; Value
        out     dx, al                  ; ... write out
        jmp     @@ET1                   ; Short pause
@@ET1:  in      al, dx                  ; Read register value
        cmp     al, cl                  ; Correct ?
        jnz     NoET                    ; No, not ETX000

        mov     ax, si                  ; Original value
        out     dx, al                  ; ...restore

        cmp     bl, ET3000VGA
        je      @@ET2
        call    Adjust                  ; Adjust to memory on card
@@ET2:  jmp     AutoDetectEnd
NoET:

; It is not an ETX000 VGA, check Paradise
; Original Paradise VGAs have at C000:007D a string "VGA="
; (according to Ferraro). First, check this, if that does not work,
; check registers as in DETECT.
;

        mov     es, [SegC000]
        cld
        mov     di, 7Dh                 ; Offset ID in BIOS
        mov     si, OFFSET Paradise_Ident
        mov     cx, SIZE Paradise_Ident ; Length of string
        repe    cmpsb                   ; Does the string match ?
        je      IsPar                   ; Yes, it is Paradise

; No identification string. Check switchability of the 4KB tiles.

        mov     dx, 3CEh
        mov     al, 09h
        out     dx, al
        inc     dx
        in      al, dx
        dec     dx
        or      al, al
        jnz     NoPar
        mov     ax, 050Fh               ; Release extended register of Paradise
        out     dx, ax

        mov     es, [SegB800]
        xor     di, di                  ; Address 0
        mov     al, 09h                 ; Sequencer register for SegSwitch

        mov     bx, 'An'                ; Test value 1
        call    CheckParadise           ; check
        jnz     NoPar                   ; No Paradise
        mov     bx, 'Lo'                ; Test value 2
        call    CheckParadise           ; check
        jnz     NoPar                   ; No Paradise

IsPar:  mov     bx, (M320x200 OR M640x400 OR M640x480 OR M800x600)*256 + ParadiseVGA
;       call    Adjust                  ; Adjust to memory on card
        jmp     AutoDetectEnd
NoPar:

; It is not a Paradise, check Oak

        mov     dx, 03deh               ; Special port Oak
        in      al, dx                  ; read
        and     al, 0E0h
        cmp     al, 060h                ; Oak ?
        jnz     NoOak                   ; No
        mov     bx, (M320x200 OR M640x400)*256 + OakVGA
        mov     al, 0Dh
        out     dx, al
        inc     dx
        jmp     @@Oak1
@@Oak1: in      al, dx
        test    al, 80h                 ; 512 KB ?
        jz      @@Oak2                  ; Jump if no
        or      bh, M800x600            ;
@@Oak2: jmp     AutoDetectEnd           ; Done

NoOak:

; unknown card

        mov     bx, (M320x200 * 256) + GenericVGA

AutoDetectEnd:
        pop     bp
        ret

ENDP    AutoDetect


; -------------------------------------------------------------------------
;
; Autodetect routines for a specific resolution. This calls AutoDetect
; to determine the card and the possible modes. Then it searches the
; table for a suitable mode. The routine delivers in di
; a pointer to the DST of the found mode, where a
; error may be entered in the stat field if no suitable mode is found.
;
; The routine searches the mode table from top to bottom, so that the mode
; with the highest resolution is found if the bitset in al contains multiple
; resolutions. For this, the mode table must be sorted by ascending
; resolutions within a card.

PROC    AutoDetectMode NEAR

        push    ax                      ; Save mode in al
        call    AutoDetect              ; Get card in bl, mode in bh
        pop     ax
        mov     di, OFFSET ModeTableEnd - SIZE TMode       ; Pointer to table end
        and     al, bh                  ; Unmask mode

; Search in the mode table

@@ModeLoop:
        cmp     [(TMode di).CardType], bl       ; Matching card ?
        jnz     @@L1                            ; No
        test    al, [(TMode di).Capabilities]   ; Matching mode ?
        jnz     @@ModeFound                     ; Mode matches
@@L1:   sub     di, SIZE TMode                  ; Next entry
        cmp     di, OFFSET ModeTable            ; Table end ?
        jnb     @@ModeLoop

; No matching mode found

        mov     di, OFFSET ModeTable            ; Take VGA320x200
        mov     [DST.Stat], grNotDetected

; Return pointer to mode entry in di

@@ModeFound:
        ret

ENDP    AutoDetectMode

