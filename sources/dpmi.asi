; [Comments translated from German to English]

; *****************************************************************************
; *                                                                           *
; *              DPMI subroutines for the SVGA.BGI driver                     *
; *                                                                           *
; * (C) 1990-94                                                               *
; * Ullrich von Bassewitz                                                     *
; * Zwehrenb�hlstra�e 33                                                      *
; * D-72070 T�bingen                                                          *
; *                                                                           *
; * E-Mail: uz@ibb.schwaben.de                                                *
; *                                                                           *
; *****************************************************************************


; DPMI runs only on 80286 and above
P286



; Gets a descriptor for a REAL-mode segment. The descriptor is a data
; descriptor with the base address of the REAL-mode segment and a limit of
; 64KB.
; To turn this into a code descriptor, call the function DPMI_MakeCodeDesc.
; The REAL-mode segment is expected in ax, the descriptor is returned in bx.
; The function is transparent in real mode, i.e. it simply returns the segment
; in bx.


PROC    DPMI_SegToDesc  NEAR

        cmp     [ProtMode], 0           ; Protected mode?
        jnz     @@L1                    ; Jump if yes
        xchg    ax, bx                  ; Segment to bx
        ret                             ; And done

;

@@L1:   push    ax                      ; Save segment

; Allocate LDT descriptor and put in bx

        xor     ax, ax
        mov     cx, 1
        int     31h
        xchg    ax, bx

; Enter base

        pop     dx                      ; Segment address
        rol     dx, 4
        mov     cl, dl
        and     cx, 000Fh
        and     dx, 0FFF0h

        mov     ax, 7                   ; Set Segment Base Address
        int     31h

; Set limit to 64KB

        xor     cx, cx
        mov     dx, 0FFFFh
        mov     ax, 8                   ; Set Segment Limit
        int     31h

; And done

        ret

ENDP    DPMI_SegToDesc




; Function to turn a data descriptor in bx into a code descriptor.
; The descriptor is expected in bx and returned in bx.
; The function is transparent in real mode, i.e. nothing happens in real mode.

PROC    DPMI_MakeCodeDesc       NEAR

        cmp     [ProtMode], 0           ; Protected mode?
        jz      @@L9                    ; Jump if no
        lar     cx, bx                  ; Access rights to cx
        xchg    ch, cl
        and     cx, 00F0h               ; Keep P/DPL/S
        or      cl, 1010b               ; Code/Non-Conform/Read
        mov     ax, 9
        int     31h
@@L9:   ret

ENDP    DPMI_MakeCodeDesc




; Release an LDT selector. Expects the selector in bx.
; The function is transparent in real mode, i.e. nothing happens in real mode.


PROC    DPMI_FreeDesc   NEAR

        cmp     [ProtMode], 0           ; Protected mode?
        jz      @@L9                    ; Jump if no
        mov     ax, 1
        int     31h
@@L9:   ret

ENDP    DPMI_FreeDesc


; Reset TASM to the correct CPU

RESETCPU