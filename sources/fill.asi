; [Comments translated from German to English]

; *****************************************************************************
; *                                                                           *
; *                   FloodFill for the SVGA.BGI driver                       *
; *                                                                           *
; * (C) 1990-94                                                               *
; * Ullrich von Bassewitz                                                     *
; * Zwehrenb�hlstra�e 33                                                      *
; * D-72070 T�bingen                                                          *
; *                                                                           *
; * E-Mail: uz@ibb.schwaben.de                                                *
; *                                                                           *
; *****************************************************************************



; =========================================================================
;
;         DW      FLOODFILL       ; Fill a bounded region using a flood fill
;
;   Input:
;      AX         The x coordinate for the seed point
;      BX         The y coordinate for the seed point
;      CL         The boundary color for the Flood Fill
;
;   Return:
;      Nothing      (Errors are returned in Device Status STAT field).
;
; This function is called to fill a bounded region on bitmap devices. The
; (X,Y) input coordinate is used as the seed point for the flood fill. (CP)
; becomes the seed point. The current FILLPATTERN is used to flood the
; region.
;


;---------------------------------------------------------------------
; ScanLeft: Searches to the left until either a pixel in the border color
; or the edge of the clip window is reached.
;
; Expects:      AX = Y
;               BX = X
;               ES = Video segment
;
; Result:       Last pixel before border color or edge in bx (= X)


PROC    ScanLeft

        push    di
        CalcAdr                         ; Calculate address
        xchg    di, ax                  ; Offset to di

; Search loop, X = bx

        mov     al, [BorderColor]
        mov     cx, [Clip_X1]           ; Into register for speed

@@L2:   cmp     bx, cx                  ; Edge of clip window?
        jl      @@L3                    ; Yes: end
        cmp     al, [es:di]             ; Border color?
        je      @@L3                    ; Yes: end

        dec     bx                      ; X := X - 1;
        sub     di, 1                   ; dec does not set all flags
        jnc     @@L2                    ; Next

; Handle segment overflow

        dec     [Seg64]                 ; one segment lower
        call    [SegSelect]             ; set
        jmp     @@L2                    ; And next pixel

; Done, edge found

@@L3:   inc     bx                      ; To last pixel before
        pop     di
        ret

ENDP    ScanLeft


;---------------------------------------------------------------------
; ScanRight: Searches to the right until either a pixel in the border color
; or the edge of the clip window is reached
;
; Expects:      AX = Y
;               BX = X
;               ES = Video segment
;
; Result:       Last pixel before border color or edge in bx (= X)


PROC    ScanRight

        push    di
        CalcAdr                         ; Calculate address
        xchg    di, ax                  ; Offset to di

; Calculate maximum number of bytes to search

        mov     cx, [Clip_X2]
        sub     cx, bx
        inc     cx

; Subtract current offset from X value

        sub     bx, di

; Border color into al

        mov     al, [BorderColor]
        cld

; Check if an overflow can occur in between

        mov     dx, di
        add     dx, cx
        jnc     @@L1
        mov     cx, di
        neg     cx
        push    dx                      ; Remaining count on stack

; Scan with REP SCASB

        repne   scasb
        pop     cx                      ; New counter
        je      @@L2                    ; Jump if found

; Set next segment

        inc     [Seg64]                 ; overflow...
        call    [SegSelect]

; Scan second (or only) half

@@L1:   repne   scasb
@@L2:
	Sub2	di			;Set to found byte or before
        add     bx, di                  ; And calculate matching X value

; End

        pop     di
        ret

ENDP    ScanRight

;---------------------------------------------------------------------------
;
; ScanDist: Scans a line between two X values until a point is reached
; that does not match the border color. If such a point is found, a
; cleared carry and the corresponding X value in bx are returned,
; otherwise a set carry.
;
; Input:        AX = Y
;               BX = X1
;               CX = X2
;               ES = Video segment
;


PROC    ScanDist

        push    di
        CalcAdr                         ; Calculate address
        xchg    di, ax                  ; Offset to di

; Calculate maximum number of bytes to search

        sub     cx, bx
        inc     cx

; Subtract current offset from X value

        sub     bx, di

; Border color into al

        mov     al, [BorderColor]
        cld

; Check if an overflow can occur in between

        mov     dx, di
        add     dx, cx
        jnc     @@L1
        mov     cx, di
        neg     cx
        push    dx                      ; Remaining count on stack

; Scan with REP SCASB

        repe    scasb
        pop     cx                      ; New counter
        jne     @@L2                    ; Jump if found

; Set next segment

        inc     [Seg64]                 ; overflow...
        call    [SegSelect]

; Scan second (or only) half

@@L1:   repe    scasb
        je      @@L3                    ; Jump if not found
@@L2:   dec     di                      ; Set to found byte
        add     bx, di                  ; And calculate matching X value

; End

        clc
        pop     di
        ret

@@L3:   stc
        pop     di
        ret


ENDP    ScanDist

;---------------------------------------------------------------------------
; Filling a horizontal line. The line ends when a point in the border color
; or the edge of the clip window is reached.
;
; Input:        AX = Y
;               BX = X
;

PROC    FillHoriz

        push    di

        mov     di, ax                  ; Y value for pattern
        and     di, 7                   ; mod 8
        mov     ch, [FillPattern + di]  ; Get fill pattern
        mov     cl, bl                  ; X value, low byte
        rol     ch, cl                  ; Align fill pattern

        CalcAdr                         ; Calculate address
        xchg    di, ax                  ; Offset to di

; Variable init

@@L1:   mov     cl, [FillColor]         ; Get color
        mov     ax, [CurrXR]
        mov     [PrevXR], ax            ; Save

; Search loop, X = bx

        mov     al, [BorderColor]
        mov     dx, [Clip_X2]           ; Into register for speed

@@L2:   cmp     bx, dx                  ; Edge of clip window?
        jg      @@L5                    ; Yes: end
        cmp     al, [es:di]             ; Border color?
        je      @@L5                    ; Yes: end

        rol     ch, 1                   ; Rotate pattern
        jnc     @@L3                    ; Jump if no point
        mov     [es:di], cl             ; Set point in fill color
        jmp     @@L4
@@L3:   mov     [BYTE es:di], 0         ; Set point in background color

; Address next pixel

@@L4:   inc     bx                      ; X := X + 1;
        inc     di
        jnz     @@L2                    ; Next

; Handle segment overflow

        inc     [Seg64]                 ; one segment higher
        call    [SegSelect]             ; set
        jmp     @@L2                    ; And next pixel

; Done, edge found

@@L5:   dec     bx                      ; Last pixel before
        mov     [CurrXR], bx            ; ... remember
        pop     di
        ret

ENDP    FillHoriz

;---------------------------------------------------------------------------
;
; ScanLine. Receives a Y value and two X values. Searches between the two
; X values and enters all points that do not match the border color into
; the stack (or the leftmost point of a line).
;
; Input:        AX = Y
;               BX = XL
;               CX = XR
;               DX = Dir
;
; Result:       Carry on stack overflow
;               Carry clear if all ok


PROC    ScanLine

        push    bp
        push    di
        push    si
        mov     bp, ax                  ; bp = Y
        mov     si, dx                  ; si = Dir

; Calculate address of pixel at XL/Y

        CalcAdr
        mov     di, ax                  ; Offset to di

; Variable init

        mov     al, [BorderColor]       ; Color into al
        mov     dx, bx                  ; XL into dx

; Search to the right until end or a pixel != border color is found

@@L2:   cmp     dx, cx                  ; XL > XR ?
        jg      @@L7                    ; Then end
        cmp     [es:di], al             ; Border color?
        jne     @@L4                    ; Jump if color != border color

@@L3:   inc     dx                      ; XL++
        inc     di
        jnz     @@L2

; Handle segment overflow

        inc     [Seg64]
        call    [SegSelect]
        jmp     @@L2

; A pixel != border color was found. Enter this into the stack

@@L4:   mov     bx, [StackPtr]
        cmp     bx, [StackTop]          ; Stack overflow?
        jae     @@L9                    ; Jump if yes
        mov     ax, dx                  ; XR value
        test    si, si                  ; Check direction
        jge     @@L5                    ; Jump if R->L
        not     ax                      ; Otherwise set flag
@@L5:   mov     [ss:bx], ax             ; X value onto stack
        mov     [ss:bx+2], bp           ; Y value onto stack
        add     [StackPtr], 4           ; Two words more on the stack

; Now continue searching until end or a pixel = border color is found
; (i.e. search for end of line)

        mov     al, [BorderColor]
@@L6:   cmp     dx, cx                  ; XL > XR ?
        jg      @@L7                    ; Jump if end
        cmp     [es:di], al
        je      @@L3                    ; Found, continue as above

        inc     dx                      ; XL++
        inc     di
        jnz     @@L6

; Handle segment overflow

        inc     [Seg64]
        call    [SegSelect]
        jmp     @@L6

; End

@@L7:   clc
@@L8:   pop     si
        pop     di
        pop     bp
        ret

; End if stack overflow

@@L9:   mov     [DST.Stat], grNoFloodMem        ; Set error flag
        stc
        jmp     @@L8

ENDP    ScanLine

;---------------------------------------------------------------------------
; CheckStack:
; Receives a coordinate and checks if it is contained in the stack.
; If yes, it is deleted and a carry is returned, if not, nothing happens
; and a cleared carry is returned.
;
; Input:        AX = Y
;               BX = X
;               CX = Dir
;

PROC    CheckStack      NEAR

        push    bp
        test    cx, cx
        jge     @@L1
        not     bx
@@L1:   mov     bp, StackBot-4          ; Stack start to bp
        mov     dx, [StackPtr]          ; Stack pointer to dx

; Search loop

@@L2:   add     bp, 4                   ; Next element
        cmp     bp, dx                  ; Stack end reached?
        je      @@L6                    ; Yes, done (not found)
        cmp     bx, [bp]                ; Does X value match?
        jne     @@L2                    ; No, next
        cmp     ax, [bp+2]              ; Does Y value match?
        jne     @@L2                    ; No, next

; Element found. Delete.

@@L3:   sub     dx, 4                   ; StackPtr -= 4;
        mov     [StackPtr], dx          ; And remember
        mov     cx, dx                  ; StackPtr
        sub     cx, bp                  ; = number of bytes
IF P80386
        shr     cx, 2                   ; / 4 because of double words
        jcxz    @@L5                    ; already done

; Shift (80386)

@@L4:   mov     eax, [bp+4]
        mov     [bp], eax               ; shift
        add     bp, 4
        loopcx  @@L4
ELSE
        shr     cx, 1                   ; / 2 because of words
        jcxz    @@L5                    ; already done

; Shift (8086)

        mov     dx, ds                  ; save ds
        mov     bx, es                  ; save es
        mov     ax, ss
        mov     ds, ax
        mov     es, ax                  ; es=ds=ss

        xchg    di, bp                  ; destination address (save di)
        xchg    ax, si                  ; save si
        lea     si, [di+4]              ; source address

        cld
        rep     movsw                   ; shift

        mov     ds, dx                  ; old ds
        mov     es, bx                  ; old es
        mov     di, bp                  ; old di
        xchg    ax, si                  ; old si

ENDIF

; End if found

@@L5:   stc
        pop     bp
        ret

; End if not found

@@L6:   clc
        pop     bp
        ret

ENDP    CheckStack


;---------------------------------------------------------------------------
; Scan

PROC    Scan NEAR
ARG     X: WORD, Y: WORD        = ArgSize
LOCAL   CurY: WORD, CurXL: WORD, PrevXL: WORD, Dir: WORD, \
        NewXL: WORD, T: WORD = LocalSize


; Build stack frame

        EnterProc LocalSize
        push    di
        push    si

;

@@L0:   mov     ax, [Y]
        add     ax, [FillDir]
        mov     [CurY], ax
        cmp     ax, [Clip_Y1]
        jl      @@L1
        cmp     ax, [Clip_Y2]
        jg      @@L1
        mov     bx, [X]
        mov     [PrevXL], bx

        add     ax, [PageOfs]
        mul     [BytesPerLine]                  ; dx:ax = CurY * MaxX
        add     bx, ax
        adc     dl, 0
        cmp     [Seg64], dl
        je      @@M1
        mov     [Seg64], dl
        call    [SegSelect]
@@M1:   mov     al, [BorderColor]
        cmp     al, [es:bx]
        je      @@L3

        mov     ax, [CurY]
        mov     bx, [X]
        call    ScanLeft
        jmp     @@L4
@@L3:   mov     ax, [CurY]
        mov     bx, [X]
        mov     cx, [CurrXR]
        call    ScanDist
        jc      @@L1

@@L4:   mov     [CurXL], bx
        mov     ax, [CurY]
        call    FillHoriz
        mov     ax, [CurXL]
        cmp     ax, [PrevXL]
        jge     @@L10
        xchg    si, ax                  ; si = CurXL
        mov     ax, [Y]
        mov     bx, si                  ; bx = CurXL
        call    ScanLeft
        cmp     bx, si
        jge     @@L8
        jmp     @@L6
@@L5:   mov     si, bx
        mov     ax, [Y]
        call    ScanLeft
@@L6:   cmp     bx, si
        jge     @@L7
        mov     si, bx
        mov     ax, [CurY]
        call    ScanLeft
        cmp     bx, si
        jl      @@L5
@@L7:   mov     dx, [FillDir]
        mov     ax, [CurY]
        mov     cx, [CurXL]
        dec     cx
        mov     bx, si
        call    ScanLine
        jc      @@L9
@@L8:   mov     dx, [FillDir]
        neg     dx
        mov     ax, [Y]
        mov     cx, [PrevXL]
        dec     cx
        mov     bx, si
        call    ScanLine
        jc      @@L9

@@L10:  mov     ax, [CurrXR]
        cmp     [PrevXR], ax
        je      @@L17
@@L11:  mov     ax, [FillDir]
        mov     [Dir], ax
        mov     bx, [PrevXR]
        mov     [NewXL], bx
        mov     ax, [CurrXR]
        mov     [PrevXL], ax
        cmp     [PrevXR], ax
        jle     @@L12
        xchg    bx, ax                  ; ax = PrevXL, bx = NewXL
        mov     [NewXL], bx
        mov     [PrevXL], ax
        mov     cx, [CurY]
        mov     [Y], cx
        neg     [Dir]
@@L12:  xchg    si, ax                  ; ax = PrevXL
        mov     ax, [Y]
        mov     bx, si
        call    ScanRight
        cmp     bx, si
        jle     @@L16
        mov     ax, [Y]
        add     ax, [Dir]
        mov     [T], ax

@@L13:  mov     si, bx
        mov     ax, [T]
        call    ScanRight
        cmp     bx, si
        jg      @@L15
@@L14:  mov     dx, [Dir]
        mov     ax, [Y]
        add     ax, dx                  ; ax += FillD
        mov     cx, si
        mov     bx, [PrevXL]
        inc     bx
        call    ScanLine
        jc      @@L9
        jmp     @@L16
@@L15:  mov     si, bx
        mov     ax, [Y]
        call    ScanRight
        cmp     bx, si
        jle     @@L14
        jmp     @@L13

@@L16:  mov     dx, [Dir]
        neg     dx
        mov     ax, [Y]
        mov     cx, si
        mov     bx, [NewXL]
        inc     bx
        call    ScanLine
        jc      @@L9
@@L17:  mov     bx, [CurXL]
        mov     [X], bx
        mov     ax, [CurY]
        mov     [Y], ax

        mov     cx, [FillDir]
        neg     cx
        call    CheckStack              ; ax = Y, bx = X
        jnc     @@L0                    ; Next round

; End with carry clear

@@L1:   clc

; Entry with carry set

@@L9:   pop     si
        pop     di
        LeaveProc
        ret     ArgSize

ENDP    Scan


;---------------------------------------------------------------------
; Actual FloodFill routine
;
; Entry occurs with the FloodFill stack, i.e. the buffer reserved by
; GRAPH for FloodFill, FillPoly etc., and which can be enlarged by the
; user as needed. The line stack is placed on this stack by copying the
; stack pointer to StackTop. The SP is set to the value StackBot (this
; should be a reasonably sufficient value for the system, here 512 bytes
; are chosen. NOTE: StackBot must be divisible by 4!!! (otherwise there
; is a risk of uncontrolled overflow, since overflow is only tested every
; four bytes, not every byte).
PROC    FloodFill

; Check if at least 100 bytes of buffer are available on the stack

        cmp     sp, StackBot + 100
        ja      @@L0                    ; Ok, there is space
        mov     [DST.Stat], grNoFloodMem; Set error
        ret                             ; And end

; Wait until the GE is ready

@@L0:   call    [GE_Ready]

; Set buffer in stack area correctly

        mov     dx, sp                  ; Get stack top
        mov     sp, StackBot            ; Set new stack
        mov     [StackPtr], sp          ; Stack grows from bottom up
        push    dx                      ; Save unchanged value
        and     dx, 0FFFCh              ; Align to double word boundary
        mov     [StackTop], dx          ; And remember as upper limit

; Initialize variables

        mov     [FillDir], -1
        mov     [BorderColor], cl
        mov     si, ax                  ; SeedX
        mov     di, bx                  ; SeedY
        mov     es, [VideoSeg]

; Check color at start point. If it is directly the border color --> end

        xchg    ax, bx                  ; ax=Y, bx=X
        mul     [BytesPerLine]
        add     bx, ax
        adc     dl, 0
        mov     [Seg64], dl
        call    [SegSelect]             ; Set segment
        cmp     [es:bx], cl             ; Color = border color?
        je      @@L99                   ; End if yes

; Go as far left as possible and put this point as start point on the
; stack. Then go as far right as possible (without hitting the border)
; and remember this point as the rightmost point.

        mov     ax, di                  ; SeedY
        mov     bx, si                  ; SeedX
        call    ScanLeft
        mov     si, bx                  ; SeedX
        mov     bp, [StackPtr]
        mov     [bp], si                ; X
        mov     [bp+2], di              ; Y
        add     bp, 4
        mov     [StackPtr], bp
        mov     ax, di                  ; SeedY
        call    ScanRight               ; bx = SeedX
        mov     [CurrXR], bx
        jmp     @@L3

; Get a value from the stack. End if stack is empty

@@L1:   mov     bp, [StackPtr]
        cmp     bp, StackBot
        je      @@L99
        sub     bp, 4
        mov     [StackPtr], bp
        mov     si, [bp]                ; X
        mov     di, [bp+2]              ; Y

 ; Extract direction from X value and set FillDir

        mov     ax, 1                   ; Dir = 1
        test    si, si                  ; Flag for Dir negative?
        jge     @@L2
        not     si                      ; X
        neg     ax                      ; Dir
@@L2:   mov     [FillDir], ax

; Draw the line that was on the stack

        mov     ax, di
        mov     bx, si
        call    FillHoriz

; Check if this line is still on the stack, delete if yes

        mov     cx, [FillDir]
        neg     cx
        mov     ax, di
        mov     bx, si
        call    CheckStack
        jc      @@L1


@@L3:   push    di
        push    si
        call    Scan
        jnc     @@L1
@@L99:  pop     sp                      ; Old SP value
        ret

ENDP    FloodFill


