[Translated from German to English]

                     SVGA.BGI - BGI Driver for Super-VGAs

                          Version 4.00 from Dec 2020

                    (C) 1990-1995 by Ullrich von Bassewitz
                            ZwehrenbÅhlstra·e 33
                              D-72070 TÅbingen
                          E-Mail: uz@ibb.schwaben.de

                     (C) 2020-2023 by Javier GutiÇrrez Chamorro
                      https://javiergutierrezchamorro.com





0. Foreword

All rights to the software described here as well as the documentation are held
by the author. The use of SVGA.BGI in your own programs is free, both for
private and commercial purposes. However, please note the following:

    Since the use of SVGA.BGI is free of charge, its use is at the sole risk
    of the user. Any liability for direct, indirect, caused or consequential
    damages that may arise from the use of SVGA.BGI is excluded.

SVGA.BGI may be freely distributed under the following conditions:

  * Distribution must be as a complete package with documentation and
    example programs.
  * Distribution must be free of charge. This means in particular that the
    driver may not be distributed on CD-ROMs without my prior written
    permission, nor may it be placed on mailboxes/FTP servers where access
    to the driver is not free for everyone.



1. Overview

SVGA.BGI is a BGI driver for Super-VGAs. Most of the VGAs available on the
market are supported.

SVGA.BGI

  * supports modes with 256 colors and resolutions up to 1280*1024,

  * supports both Borland compilers, i.e. Turbo Pascal and Borland C++,

  * supports all functions specified in the "Device Drivers Toolkit"
    including FloodFill,

  * is significantly faster than the standard drivers in many functions,

  * also comes in a DPMI version,

  * comes with various demo programs,

  * and may be freely distributed as long as my copyright is not
    removed and as long as it is done completely and unmodified.



2. General

2.1. Supported Cards

So far, the following cards are supported:

  * Cards with Tseng ET3000 chipset. These cards are available from various
    manufacturers.

  * Cards with Tseng ET4000 chipset. These cards are available from various
    manufacturers.

  * Cards with Trident 8800/8900 chipset. These cards are available from
    various manufacturers.

  * Video7 cards from the manufacturer Headland.

  * The VGA Wonder from ATI.

  * Cards with Paradise chipset. These cards are available from various
    manufacturers.

  * S3 cards. From version 3.4 onwards, the accelerator functions of the
    chipset are also supported.

  * Cards that meet the VESA standard or provide a VESA interface.



2.2. Example Programs

Due to the higher distribution, all examples in the following
description are programmed in Turbo Pascal.



3. Features

The driver supports all functions specified in the Device Drivers Toolkit.
However, due to the hardware available (memory configuration or chipset),
there may be some minor limitations (for example, in the support of
multiple screen pages).

I have made an effort to implement the functions not only correctly but also
as quickly as possible - the latter is mainly the case for the functions
in which I was personally interested, such as drawing lines and block
functions.



4. The Modes of the Driver

The individual modes are assigned the following constants:

Mode-Number Resolution
---------------------------------------------------------------------
     0       320*200. This mode is supported by every VGA card
             not just by the cards supported by the driver.
     1       Autodetect. Uses the highest resolution of the card.
             See the corresponding section.
     2       640*400, Autodetect, see section "Autodetect".
     3       640*480, Autodetect, see section "Autodetect".
     4       800*600, Autodetect, see section "Autodetect".
     5       1024*768, Autodetect, see section "Autodetect".
     6       1280*1024, Autodetect, see section "Autodetect".
     7       640*350, ET3000.
     8       640*480, ET3000.
     9       800*600, ET3000.
     10      640*350, ET4000.
     11      640*400, ET4000.
     12      640*480, ET4000.
     13      800*600, ET4000.
     14      1024*768, ET4000.
     15      640*400, Trident 8900
     16      640*480, Trident 8900
     17      800*600, Trident 8900.
     18      1024*768, Trident 8900.
     19      640*400, Video7.
     20      640*480, Video7.
     21      800*600, Video7.
     22      640*400, ATI VGA Wonder.
     23      640*480, ATI VGA Wonder.
     24      800*600, ATI VGA Wonder.
     25      1024*768, ATI VGA Wonder.
     26      640*400, Paradise.
     27      640*480, Paradise.
     28      800*600, Paradise.
     29      640*350, Everex.
     30      640*400, Everex.
     31      640*480, Everex.
     32      800*600, Everex.
     33      640*400, Oak.
     34      800*600, Oak.
     35      640*480, S3.
     36      800*600, S3.
     37      1024*768, S3.
     38      1280*1024, S3.
     39      640*400, VESA.
     40      640*480, VESA.
     41      800*600, VESA.
     42      1024*768, VESA.
     43      1280*1024, VESA.

Depending on the card and settings, especially the modes with higher
resolutions may be displayed as interlaced or non-interlaced. Please make
sure that the corresponding mode matches the capabilities of your monitor
( Fixed-frequency monitors can be damaged by incorrect deflection frequencies).



5. Integrating the Driver

The driver is integrated via the InstallUserDriver procedure. The
first parameter of InstallUserDriver is the name of the driver (without the
extension), the second parameter is a pointer to a detect routine that can test
the hardware for the presence of the corresponding card. Instead of a
corresponding routine, the driver's autodetect modes (see section
"Autodetect") can be used.

If the integer value returned by InstallUserDriver is < 0, an error
has occurred, if it is greater, it represents the number of the driver directly
in version 6.0, in versions 5.0 and 5.5 after adding 5. The following
example shows how integration in Turbo Pascal might look.


        VAR
          GraphMode, GraphDriver : INTEGER;

        BEGIN
          { Install graphics driver }
          GraphDriver := InstallUserDriver ('SVGA', NIL);
          IF (GraphDriver < 0) THEN BEGIN
            { Error handling }
            ...
          END;

          { For versions before TP 6.0, add this line}
          { Inc (GraphDriver, 5); }

          { Set desired mode and turn on graphics }
          GraphMode := 0;
          InitGraph (GraphDriver, GraphMode, PathToDriver);
          ...
        END;

If the driver is to be linked as an OBJ file into the executable program,
the following steps must be carried out in exactly this order:

  * "Installation" of the driver with InstallUserDriver. This procedure
    informs the graphics kernel that there is a driver named
    "SVGA".

  * "Registration" of the driver with RegisterBGIDriver. This procedure
    informs the graphics kernel that the driver (if it is to be used)
    is not to be loaded from disk, but that it is already
    in memory.

  * Turning on the graphics mode with InitGraph.

The following code snippet shows, by way of example, how the integration can
take place. It is assumed that the driver has previously been converted into
an OBJ file using

        BINOBJ SVGA.BGI SVGA.OBJ SVGADRIVER

(C programmers: The corresponding program is called BGIOBJ and is a bit
more complicated to use. When called, all parameters must be specified!
Just call BGIOBJ without parameters and follow the instructions for help.)


    { The driver declared as a procedure }
    PROCEDURE SVGADriver; FAR; EXTERNAL;

    { Linking the driver }
    {$L SVGA.OBJ}

    VAR
      GraphDriver : INTEGER;          { Driver number }


    PROCEDURE Install;
    { Performs the installation of the driver }
    BEGIN
      GraphDriver := InstallUserDriver ('SVGA', NIL);
      IF (GraphDriver < 0) THEN Error;
      IF (RegisterBGIDriver (@SVGADriver) < 0) THEN Error;
    END;


    BEGIN                         { Main program }
      ....
      Install;
      GraphMode := 1;             { Autodetect }
      InitGraph (GraphDriver, GraphMode, '');
      { Error evaluation must follow }
      ....
    END.

If you have difficulties addressing the card, please first check
whether the included graphics programs (see README file) work on your system.
If so, please compare your initialization with that in the included source
codes. If you have difficulties with the autodetect modes, please read
section "Autodetect".



6. Addressing Colors

When turning on the graphics, the driver initializes colors 0-15 with
standard values. These colors correspond to the colors in the 16-color modes. All
further color values are not allocated by the driver, they contain values that
the video BIOS sets during initialization and can be defined by the user.
The SetRGBPalette procedure is exclusively used to set the colors. It should be
noted that the lowest 2 bits of the RGB values passed are not allocated. Valid
values are therefore 0, 4, 8... (the reason for this is compatibility with IBM's
8514 card).



7. Individual BGI Functions

7.1. FillPoly

The driver does not emulate the FillPoly function (like most other
BGI drivers for graphics cards), but performs the operation itself. Since the
driver uses a different algorithm than the graphics kernel, the
result of the function may differ slightly in extreme cases.



7.2. FloodFill

The FloodFill function is available. It may be necessary, with high
resolutions and complex fill patterns, to increase the size of the buffer
(function SetGraphBufSize).



7.3. PutImage

PutImage has supported an additional mode called TransPut since version 3.21
(actually even earlier, but officially since this version). In this mode, the
pixels are transferred just like in CopyPut, with the exception of pixels of
color 0, which are not transferred. With the help of TransPut, "transparent"
images can be displayed on the screen, simplifying the programming of sprites.
The constant for TransPut has the value 5.

Example of the call:

        CONST
          TransPut = 5;

          ...
          PutImage (100, 100, P^, TransPut);
          ...



7.4. SetActivePage and SetVisualPage

Since version 3.50, the page switching function has been extended to VESA cards.
The card or driver must support version 1.2 of the standard for this.
This function was previously only available for a few cards.
The following table gives a guideline(!) for how many pages are supported with
the respective memory configuration, the exact number depends on the
chipset and the driver.

   ⁄ƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
   ≥Resolution ≥               Number of Pages             ≥
   ≥           ≥    512KB           1MB           2MB      ≥
   √ƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥
   ≥  320*200  ≥     2       ≥       4      ≥      8       ≥
   ≥  640*400  ≥     2       ≥       4      ≥      8       ≥
   ≥  640*480  ≥     1       ≥       2      ≥      4       ≥
   ≥  800*600  ≥     1       ≥       2      ≥      4       ≥
   ≥ 1024*768  ≥     0       ≥       1      ≥      2       ≥
   ≥ 1280*1024 ≥     0       ≥       0      ≥      1       ≥
   ¿ƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ


The following cards or chipsets are supported natively, i.e. without a loaded
VESA driver:

        ET3000                  (untested)
        ET4000
        Trident 8900
        PVGA (Paradise)         (untested)
        S3



8. Autodetect

Since version 3.00, the driver has several autodetect modes, in which the
driver tries to automatically detect the graphics card and set the
correct parameters. This should always work if you have a VESA card and
(if necessary) have loaded the corresponding VESA driver. This driver is
normally located on the disks that came with your VGA and is called
VESA.COM, VESA.EXE or sometimes (Trident cards) also VESA9000.EXE.
The driver is loaded resident and then provides the VESA interface.
Without the VESA driver, there is a possibility that the driver does not
recognize your card. If necessary, you have to fall back on the card-specific
modes.

Through my fax/modem server, a package is available that contains public domain
VESA drivers for many common cards. Use the login/password "bgi" for
downloading - the file is named VESADRIV.ZIP.



9. DPMI Version for BP 7.0

The package includes a DPMI-capable version of the driver. This version can be
found in the SVGA directory under the name SVGA.BP7 (and must be renamed to
SVGA.BGI before use).

The driver should behave just like the normal driver, with the exception of
the following differences:

  * The BP7 version does not run under Turbo Pascal 6.0 and earlier as well as
    any version of Borland C (up to 3.1).

  * Due to the more complicated segment switching, the version may be
    slightly slower.

If errors occur when using the driver, I would like to ask you to report
them to me. Problems are (if at all) most likely to occur with the automatic
detection of the cards.



10. Options

The driver currently knows several options with which its behavior can be
influenced. These options are set before the program starts by assigning
them to the environment variable SVGAOPTS.
WARNING: Case sensitivity is important!

      V Disables VESA detection. Since some features of the driver cannot
        be used with an active VESA driver (e.g. multiple screen pages),
        and since direct control may be slightly faster depending on the card,
        this option can be used to disable VESA detection.

      F Disables fast DPMI segment switching in VESA mode.
        The driver uses a relatively aggressive optimization to control VESA
        compatible cards in protected mode with acceptable speed.
        If problems arise with this, either the VESA detection or the
        optimization can be disabled. The "problems" can be easily recognized
        as the program terminating with a general protection fault.
        WARNING: The driver becomes catastrophically slow with this option
        set (but works reliably)!
        This switch only matters in protected mode and only if the card is
        operated as a VESA card.

      3 Disables hardware functions for S3 cards. When using cards with
        S3 chipset, the hardware of the chipset is normally used to perform
        some BGI functions faster. If there are problems, this option can be
        set to disable the use of the graphics engine. The driver then performs
        all operations via software (like with other cards).

      M Forces the use of VESA mode numbers. Has no effect if a VESA driver
        is used. This allows "native" use of chipsets whose mode numbers do
        not match those used in the driver. To do this, a VESA driver is
        loaded, VESA detection is disabled with 'V', and the use of VESA mode
        numbers is forced with 'M'. This way, the VESA driver is only used to
        switch to graphics mode.

Examples for setting the options:

    REM Disable VESA detection and fast VESA segment switching
    SET SVGAOPTS=VF

or

    REM Disable VESA detection
    SET SVGAOPTS=V



11. Errors in UNIT Graph

11.1 Error Codes

Due to an error in UNIT Graph, the negative error codes returned by the
driver are passed on as positive to the application: The status field of the
driver, through which the error codes are reported back, is 1 byte large.
Since the error codes are negative values, this field should have been declared
as SHORTINT. However, the developers overlooked this and declared the field as
BYTE, which leads to the error codes not being sign-extended correctly.
A query like the following illustration provides a remedy.
Possibly, GraphResult can be redefined accordingly.

    VAR
      Result : INTEGER;

    BEGIN
      { Turn on graphics }
      InitGraph (GraphDriver, GraphMode, '');

      { Evaluate error code. The typecast truncates the
        upper 8 bits, the assignment to an INTEGER sign-extends.
      }
      Result := SHORTINT (GraphResult);
      IF (Result <> 0) THEN BEGIN
        Writeln (GraphErrorMsg (Result));
        Halt;
      END;
      ....
    END;



11.2 SetGraphMode

The SetGraphMode function does not work correctly when mode numbers greater than
10 are specified. It is advised not to use this function. Instead, use calls to
CloseGraph and InitGraph.



11.3 RestoreCRTMode and SetGraphMode

The functions do not work correctly under Borland Pascal 7.0 in protected mode,
possibly resulting in a GP fault.



11.4 RegisterBGIDriver

Manually loaded (i.e. linked as .OBJ file or loaded from a resource file)
drivers must be located at an address with an offset of 0 under Borland Pascal
7.0 in protected mode. Otherwise, the graphics kernel may terminate the program
with an error message upon the second call to InitGraph.

To ensure that the driver is located at an address with offset 0 when linked as
an .OBJ file, please create a separate module that contains only the driver.
Export the address of the driver and perform the graphics initialization in
another module.



12. Miscellaneous

12.1. Mouse Support

One of the most frequently asked questions is about mouse support in the
extended modes (often also asked as "Why doesn't the mouse work all of a sudden?").
The fact is that the mouse driver does not know the extended modes of the Super-VGA cards,
because these modes are controlled differently on all cards.
For this reason, the mouse driver is not able to display a mouse cursor in the
extended modes. However, the mouse driver still keeps track of the
mouse movements, so it is possible to query the mouse position and
display your own mouse cursor. The following things should be noted:

  * The Turbo Pascal/Turbo C graphics kernel (and the driver) are not
    reentrant. It is therefore not possible to draw a mouse cursor using
    GRAPH and the interrupt handler of the mouse driver. The drawing
    of the cursor must be done synchronously in the program.
  * Since the mouse driver does not know the resolution of the screen, it is
    (with some drivers) possible that the pixel values provided by the mouse
    driver are incorrect. This can be remedied by evaluating the actual
    mouse movements (in Mickeys) (or by introducing a conversion constant as in
    c't 6/90, p. 274).
  * The use of GetImage/PutImage for cursor display is not recommended, as
    PutImage refuses to display if parts of the cursor are outside the screen.
    This leads to the unpleasant effect that the mouse cursor disappears when
    touching the edges.
  * For more information on this topic (and a sample program in C),
    see the article in c't 6/90, p. 274.
  * I have a module available for a fee, which I wrote for mouse support.
    This module can only serve as an example for your own
    programming, as it is designed to work with a (also from
    me) multitasking kernel. It cannot be compiled or run on its own,
    but it shows the basic approach.

I would like to emphasize again that I do not have a
ready-made module for mouse querying. However, if you have
corresponding routines, I am happy to include them in the driver.



12.2. Support for more than 256 colors

Due to a design flaw (unfortunately, I can?t think of another term)
the BGI concept cannot support more than 256 colors. The graphics kernel
directly truncates the high byte of the passed color value at the top level
(if you like, you can take a look at the code of SetColor with the Turbo Debugger...).
Also, the interface to the driver is only 8 bits wide (the color value is passed as a byte).
This means there will be no driver for HiColor cards or similar!



12.3. 286 and 386 Versions of the Driver

Tests conducted by me have shown that a 80286 version of the driver
shows no measurable differences to the 8086 version.

A 80386 version, which was created by me as a trial, is slightly
faster in some few functions than the normal version. Which functions
these are cannot be precisely specified, as this also depends on the
used card. On ISA cards (16 Bit bus), PutImage is the only function where
the differences are significant (about 20-25%), and only if mode
*not* CopyPut is specified (so, e.g., XORPut). On VLB and PCI cards (32
Bit bus), some of the fill functions are faster as well, as 32
Bit operations are used.

Those who want to conduct their own tests can use the program BGIBench,
which is located in the BGIBENCH directory. The 80386 version of the driver
can be found as SVGA386.BGI or SVGA386.BP7 in the SVGA directory.

WARNING:
  1. This 80386 version crashes on 80286 (or even 8086) computers
     without any comment.
  2. The name is really "SVGA386"; this name must also be
     specified in RegisterBGIDriver.



12.4. Other Software

The package also includes some programs, please read the
README file on the diskette.



12.5. BGI Drivers for Printers, Plotters, and PCX Files...

...are available for free through my fax/modem server at the phone number
07071/440588. Further information can be obtained online.



13. Support for Additional Cards

If you have information about additional cards that you would like to be
supported, please provide me with this information.
I am particularly interested in information about additional accelerator
cards.



14. Support

There is no support in the form (after all, SVGA.BGI is a "free" product).
Nevertheless, I am interested in hearing about errors or new applications.
You can get new versions (if any are available) via modem at
07071/440588. Login: svga / Password: svga. The computer will immediately
start the Z-Modem program and send the file SVGAVVVV.ZIP (VVVV = Version).



15. Files in the Package

The present archive must contain the following files:


In the directory  SVGA
                SVGA.BGI        The BGI driver
                SVGA386.BGI     80386 version of the driver. See text above.
                SVGA.BP7        DMPI version, see text.
                SVGA386.BP7


In the directory  BGIBENCH
                BGIBENCH.EXE    Measurement program for BGI drivers.
                BGIBENCH.PAS    The source code for it.
                BGIBENCH.DOC    The documentation.


In the directory  PIXFONT
                PIXFONT.PAS     Source text of a module for outputting
                                arbitrary pixel fonts.
                PIXFONT.DOC     The documentation for it.
                GETFONT.EXE     Program for saving the VGA fonts.
                GETFONT.PAS     The source text for it.
                *.FNT           Various pixel fonts.
                FONTDEMO.EXE    Example program for using the pixel fonts.
                FONTDEMO.PAS    The source text for it.
                FONTDEMO.DOC    The documentation for it.
                PIXFONT.C       C version of the module.
                PIXFONT.H       Header file for it.
                FONTTEST.EXE    Test program for the C version.
                FONTTEST.C      The source text for it.
                FONTTEST.DOC    The documentation for it.


In the directory  PCXVIEW
                PCXVIEW.EXE     A program for viewing PCX images as
                                an example for the integration of SVGA.BGI and
                                the use of the 256-color palette.
                PCXVIEW.PAS     The source code for it.
                PCXVIEW.DOC     The documentation for it.


In the directory  SVGADEMO        A demo program in C for the application of SVGA.BGI
                                by Mr. Jung-Merkelbach.


In the directory  BGILIB
                MAKELIB.BAT     Batch file by Mr. Jung-Merkelbach for
                                creating two libraries for the C compiler,
                                which contain the complete fonts and drivers as OBJ
                                files.
                FONTTEST.C      Der Quelltext dazu.
                FONTTEST.DOC    Die Dokumentation dazu.


Im Verzeichnis  PCXVIEW
                PCXVIEW.EXE     Ein Programm zum Ansehen von PCX-Bildern als
                                Beispiel fÅr die Einbindung von SVGA.BGI und
                                die Verwendung der 256-Farben Palette.
                PCXVIEW.PAS     Der Quellcode dazu.
                PCXVIEW.DOC     Die Dokumentation.


Im Verzeichnis  SVGADEMO        Ein Demoprogramm in C zur Anwendung von SVGA.BGI
                                von Herrn Jung-Merkelbach.


Im Verzeichnis  BGILIB
                MAKELIB.BAT     Batch-Datei von Herrn Jung-Merkelbach zur
                                Erzeugung zweier Libraries fÅr den C-Compiler,
                                die die kompletten Fonts und Treiber als OBJ-
                                Dateien enthalten.

